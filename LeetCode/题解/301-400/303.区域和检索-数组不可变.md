# [303.区域和检索-数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)

## 1. 题目信息

### 1.1 题目描述

给定一个整数数组 `nums`，求出数组从索引 `i` 到 `j` （  $i\le j$ ）范围内元素的总和，包含 `i, j` 两端点。你需要实现 `NumArray` 类中的构造器和 `sumRange` 方法：

 1. 构造器 `NumArray(int[])` 使用数组 `nums` 初始化对象
 2. `sumRange(int, int)` 方法返回数组 `nums` 从索引 `i` 到 `j`( $i\le j$ )范围内元素的总和，包含 `i, j` 两点（也就是 $\displaystyle\sum_{k=i}^j nums[k]$）

其中：

* $0 \le nums.length \le 10^4$
* $-10^5 \le nums[i] \le 10^5$
* $0 \le i \le j < nums.length$
* 最多调用 $10^4$ 次 `sumRange` 方法

### 1.2 示例输出

假设数组 `nums = [-2, 0, 3, -5, 2, -1]`，并依次调用 `sumRange` 函数：

* `sumRange(0, 2)`
* `sumRange(2, 5)`
* `sumRange(0, 5)`

输出：`[null, 1, -1, -3]`

## 2. 解题思路

### 2.1 思路

可以在每次调用 `sumRange` 函数的时候计算一次对应范围内的元素，但是这样会导致时间复杂度变为 $O(n(j-i+1))$ （调用 $n$ 次，每次需要遍历 $j-i+1$ 长度的子数组）。这种方案可以但并不好。

所以有没有一种方案可以降低 `sumRange` 函数的时间复杂度呢？是有的，这需要在构造器中对对象做一些特殊处理。即使用一个数组来保存不同区间元素[前缀和](../../概念梳理/算法思想/前缀和.md)。但是前缀和的递推公式 $b[i]=b[i-1]+a[i]$ 在 $i=0$ 时会有 `-1` 的特殊情况，所以统一将前缀和数组的下标做加一处理。

## 3. 代码实现

### 3.1 实现

``` java {.line-numbers}
/**
 * 本题使用的数据结构<br>
 * 通过这个数据结构应该能够快速得到索引位置{@code i}和索引位置{@code j}之间的元素和
 *
 * @author lixiangyu
 */
class NumArray {
    /**
     * 保存前缀和的数组
     */
    private int[] preSum;

    /**
     * 默认构造器, 在这里需要对数组做特殊处理, 尽量降低查找时的时间复杂度
     *
     * @param nums 一个数组
     */
    public NumArray(int[] nums) {
        // 数组长度
        int n = nums.length;
        /*
         * 如果最后返回的是: preSum[i, j] = preSum[j] - preSum[i - 1]
         * 在索引0处需要做特殊判断, 为了避免这种情况, 整体向右移一位, 相应的长度需要加1
         */
        preSum = new int[n + 1];
        for (int i = 0; i < n; i++) {
            preSum[i + 1] = preSum[i] + nums[i];
        }
    }

    /**
     * 得到索引位置{@code i}和索引位置{@code j}之间的元素和
     *
     * <p>
     * 思路:<br>
     * 最简单的思路是在每次查询的时候遍历数组, 时间复杂度是{@code O(∑)}(∑是两索引间的元素个数),
     * 在反复查询的场景下, 可能会导致超时<br>
     * 所以使用前缀和对数组做预处理, 使计算元素和的时间复杂度将为{@code O(1)}<br>
     * <b>注: 前缀和是指第一个元素到第{@code i}个元素之间的和</b>
     * </p>
     *
     * @param i 一个索引位置
     * @param j 一个索引位置
     * @return 这两个索引之间的元素和
     */
    public int sumRange(int i, int j) {
        return preSum[j + 1] - preSum[i];
    }
}
```

## 4. 参考

* [前缀和](../../概念梳理/算法思想/前缀和.md)

---

<div>
标签：
<button disabled style="border: 1px solid #4AA3DF;border-radius: 50px;color: black; background: #4AA3DF;">&nbsp;数组&nbsp;</button>
<button disabled style="border: 1px solid #4AA3DF;border-radius: 50px;color: black; background: #4AA3DF;">&nbsp;动态规划&nbsp;</button>
<button disabled style="border: 1px solid #4AA3DF;border-radius: 50px;color: black; background: #4AA3DF;">&nbsp;前缀和&nbsp;</button>
</div>
