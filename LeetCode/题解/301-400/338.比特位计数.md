# [338.比特位计数](https://leetcode-cn.com/problems/counting-bits/)

## 1. 题目信息

### 1.1 题目描述

给定一个非负整数 `num`, 对于 $0 \le i \le num}范围中的每个数字 `i`, 计算其二进制数中的 `1` 的数目并将它们作为数组返回

### 1.2 示例输出

**示例1**

输入： `2`
输出： `[0, 1, 1]`

**示例2**

输入： `5`
输出： `[0, 1, 1, 2, 1, 2]`

## 2. 解题思路

### 2.1 思路一

不妨先列举几个十进制数的二进制表示（下标表示进制）：

$$
\begin{aligned}
0_{(10)}&=0_{(2)}\\
1_{(10)}&=1_{(2)}\\
2_{(10)}&=10_{(2)}\\
3_{(10)}&=11_{(2)}\\
4_{(10)}&=100_{(2)}\\
5_{(10)}&=101_{(2)}\\
6_{(10)}&=110_{(2)}\\
7_{(10)}&=111_{(2)}
\end{aligned}
$$

可以看到在移除一个二进制数（ `number` ）的最低位后，它将和 $\lfloor \frac {number} 2 \rfloor$ 的二进制表示相同。对于奇数，`1` 的个数需要加 `1`；对于偶数，`1` 的个数是相同的。

根据这个结论，得到递推式：$bitNumber[i] = bitNumber[\lfloor \frac i 2 \rfloor] + (i \% 2)$，其中 `bitNumber` 是一个保存二进制数的数组（除 `2` 和判断奇偶性均可通过位运算实现）。

### 2.2 思路二

尝试移除一下二进制数的高位：

$$
\begin{aligned}
4_{(10)}&=100_{(2)}\to 00_{(2)}=0_{(10)}\\
5_{(10)}&=101_{(2)}\to 01_{(2)}=1_{(10)}\\
6_{(10)}&=110_{(2)}\to 10_{(2)}=2_{(10)}
\end{aligned}
$$

对于 $2^n$ 的数来说，移除最高位后一定是 `0`，因为这些数的二进制表示只有最高位是 `1`，其他位都是 `0`。对于其他的数，他们与转换后的数之间差了一个离他最近的 $2^n$ 的举例，同时在 `1` 的个数上也差了 `1` 个。

根据这个结论，可以得到递推式：$bitNumber[i] = bitNumber[i - distance] + 1$，其中 $distance = max(2^n), \enspace n \le i$。

## 3. 代码实现

### 3.1 实现一

```java {.line-numbers}
public int[] countBits(int num) {
    int[] result = new int[num + 1];
    for (int i = 1; i <= num; i++) {
        result[i] = result[i >> 1] + (i & 1);
    }
    return result;
}
```

### 3.2 实现二

```java {.line-numbers}
public int[] countBits(int num) {
    int[] result = new int[num + 1];
    int highBit = 0;
    for (int i = 1; i < num; i++) {
        if ((i & (i - 1)) == 0) {
            highBit = i;
        }
        result[i] = result[i - highBit] + 1;
    }
    return result;
}
```

## 4. 参考

待补充

---

<div>
标签：
<button disabled style="border: 1px solid #4AA3DF; border-radius: 50px; color: black; background: #4AA3DF;">&nbsp;动态规划&nbsp;</button>
<button disabled style="border: 1px solid #4AA3DF; border-radius: 50px; color: black; background: #4AA3DF;">&nbsp;位运算&nbsp;</button>
</div>
