---
title: 1806.还原排列的最少操作步数
katex: true
categories:
  - LeetCode
  - 题解
  - 1801-1900
description: 可以模拟操作，同时也有复杂的数学逻辑推导
tags:
  - 模拟
  - 数学
abbrlink: 125cfb1b
date: 2021-03-29 14:01:30
cover: https://images.unsplash.com/photo-1587471384749-6d25c9944c5a?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80
---

## 题目信息

### 题目描述

给你一个偶数 `n` ，已知存在一个长度为 `n` 的排列 `perm` ，其中 `perm[i] == i`（下标从 `0` 开始计数）。

在一步操作中，你将创建一个新数组 `arr` ，对于每个 `i` ：

如果 `i % 2 == 0` ，那么 `arr[i] = perm[i / 2]`
如果 `i % 2 == 1` ，那么 `arr[i] = perm[n / 2 + (i - 1) / 2]`
然后将 `arr` 赋值给 `perm` 。

要想使 `perm` 回到排列初始值，至少需要执行多少次操作？ 返回最小的非零操作步数。

{% note info flat %}
$2 <= n <= 1000$， `n` 是一个偶数
{% endnote %}

### 示例输出

{% tabs sample %}
<!-- tab 示例输出1 -->
输入： `n = 2`
输出： `1`
<!-- endtab -->

<!-- tab 示例输出2 -->
输入： `n = 4`
输出： `2`
<!-- endtab -->

<!-- tab 示例输出3 -->
输入： `n = 6`
输出： `4`
<!-- endtab -->
{% endtabs %}

## 解题思路

{% tabs solution %}
<!-- tab 模拟 -->
如果不能一下发现其中的数学规律，那么直接模拟就是最好的思路。没啥说的，按照题意直接写代码就完事了。
<!-- endtab -->

<!-- tab 数学推导 -->

{% note info flat %}
参考[数学 O(n) 算法](https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solution/shu-xue-on-suan-fa-by-arsenal-591-xatz/)题解进行整理
{% endnote %}

将 `n = 2, 4, 6` 情况中的数组交换情况列举一下：

{% tabs 数学推导-举例 %}
<!-- tab n = 2 -->
| 索引 | 0 | 1 |
| :-: | :-: | :-: |
| 交换位置的索引 | 0 | 1 |
<!-- endtab -->

<!-- tab n = 4 -->
| 索引 | 0 | 1 | 2 | 3 |
| :-: | :-: | :-: | :-: | :-: |
| 交换位置的索引 | 0 | 2 | 1 | 3 |
| 第1次操作 | 0 | 2 | 1 | 3 |
| 第2次操作 | 0 | 1 | 2 | 3 |
<!-- endtab -->

<!-- tab n = 6 -->
| 索引 | 0 | 1 | 2 | 3 | 4 | 5 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 交换位置的索引 | 0 | 3 | 1 | 4 | 2 | 5 |
| 第1次操作 | 0 | 3 | 1 | 4 | 2 | 5 |
| 第2次操作 | 0 | 4 | 3 | 2 | 1 | 5 |
| 第3次操作 | 0 | 2 | 4 | 1 | 3 | 5 |
| 第4次操作 | 0 | 1 | 2 | 3 | 4 | 5 |
<!-- endtab -->
{% endtabs %}

可以发现，对数组中的每个元素 `i`，假设使用 `f(i)` 来表示一次操作后的下标变换，那么（不需要考虑数组中索引为 `0` 和 `n - 1` 的位置，可以看到这两个位置的数是不会调换的）：
$$
f(i)=
\begin{cases}
2i, &i < \cfrac n 2\\
2i−(n−1), & i \ge \cfrac n 2
\end{cases}
$$

即：$f(i) \equiv 2i \mod (n - 1)$（$i \in [1, n - 1)$）。

假设：$f^k(i)$ 表示第 $k$ 次操作后元素 $i$ 的下标，那么： $f^2(i)=f(f(i)), f^3(i)=f(f(f(i))), \dots, f^k(i)=2^ki \mod (n - 1)$。

为了使所有元素都回到对应的位置上，需要有：$f^k(i) \equiv 2^ki \equiv i \mod (n - 1)$（$i \in [1, n - 1)$）。

当 $i = 1$ 时，$f^k(1) \equiv 2^k \equiv 1 \mod (n - 1)$，如果存在 $k$ 使得该式子恒成立，那么在同乘 $i$ 后的式子 $f^k(i) = i \mod (n - 1)$ 也是恒成立的。因此问题最终可以简化为：找到一个最小的 $k$，使 $2^k \equiv 1 \mod (n - 1)$ 恒成立。

根据[欧拉定理](https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA))：

$$
\alpha^{(\varphi(n))} \equiv 1 \mod n
$$

由于 $n - 1$ 是奇数，$2$ 是偶数，所以 $k = \varphi(n - 1)$ 一定是解，并且总时间复杂度 $= O(n - 1) = O(n)$。

<!-- endtab -->
{% endtabs %}

## 代码实现

{% tabs code %}
<!-- tab 模拟 -->
```java
public int reinitializePermutation(int n) {
    // 初始化perm数组
    int[] perm = new int[n];
    for (int i = 0; i < n; i++) {
        perm[i] = i;
    }

    // 最终结果
    int result = 0;

    while (true) {
        // 每次都新创建一个arr数组
        int[] arr = new int[n];

        // 标志操作是否结束
        boolean flag = true;

        // 对arr数组赋值
        for (int i = 0; i < n; i++) {
            if ((i & 1) == 0) {
                arr[i] = perm[i / 2];
            } else {
                arr[i] = perm[n / 2 + (i - 1) / 2];
            }
            // 如果存在与原数据不一样的数据就继续操作, 否则则终止操作
            if (arr[i] != i) {
                flag = false;
            }
        }

        // 统计操作次数
        result++;
        // 更新perm数组
        perm = arr;

        // 如果操作结束就退出
        if (flag) {
            break;
        }
    }

    return result;
}
```

{% note success flat %}
执行用时：29 ms, 在所有 Java 提交中击败了100.00%的用户
内存消耗：37.9 MB, 在所有 Java 提交中击败了100.00%的用户
{% endnote %}
<!-- endtab -->

<!-- tab 数学推导 -->

```java
public int reinitializePermutation(int n) {
    if (n == 2) {
        return 1;
    }

    int result = 2;
    int count = 1;

    while (result != 1) {
        count++;
        result = result * 2 % (n - 1);
    }

    return count;
}
```

{% note success flat %}
执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
内存消耗：35.5 MB, 在所有 Java 提交中击败了100.00%的用户
{% endnote %}
<!-- endtab -->
{% endtabs %}

---
