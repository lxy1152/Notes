---
title: 1814.统计一个数组中好对子的数目
katex: true
categories:
  - LeetCode
  - 题解
  - 1801-1900
description: 第 49 场双周赛，找到数学规律简化运算
tags:
  - 周赛
  - 哈希
  - 数组
abbrlink: 1f3d2de9
date: 2021-04-06 13:17:18
cover: https://rmt.dogedoge.com/fetch/~/source/unsplash/photo-1617571736695-5127086fb2af?ixid=MXwxMjA3fDB8MHx0b3BpYy1mZWVkfDE0fGJvOGpRS1RhRTBZfHxlbnwwfHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=500&q=80
---

## 题目信息

### 题目描述

给你一个数组 `nums`，数组中只包含非负整数。定义 `rev(x)` 的值为将整数 `x` 各个数字位反转得到的结果。比方说 `rev(123) = 321`，`rev(120) = 21`。我们称满足下面条件的下标对 `(i, j)` 是**好的**：

- `0 <= i < j < nums.length`
- `nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])`

请你返回好下标对的数目。由于结果可能会很大，请将结果对 $10^9 + 7$ 取余后返回。

{% note info flat %}
- $1 \le nums.length \le 10^5$
- $0 \le nums[i] \le 10^9$
{% endnote %}

### 示例输出

{% tabs sample %}
<!-- tab 示例输出1 -->
输入： `nums = [42, 11, 1, 97]`
输出： `2`
<!-- endtab -->

<!-- tab 示例输出2 -->
输入： `nums = [13, 10, 35, 24, 76]`
输出： `4`
<!-- endtab -->
{% endtabs %}

## 解题思路

暴力破解的时间复杂度是 $O(n^2)$ 会超时，需要进行简化。

考虑题目中的这个条件： `nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])` ，将它重新整理一下，可以得到：`nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])`。

因此只要出现重复的 `nums[i] - rev(nums[i])` ，它们两两之间就可以进行配对，所以只做一次遍历就可以了。

## 代码实现

```java
public static int countNicePairs(int[] nums) {
    Map<Integer, Integer> map = new HashMap<>();
    long result = 0;
    for (int i : nums) {
        int num = i - reverse(i);
        result += map.getOrDefault(num, 0);
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
   return (int) (result % 1000000007);
}

public static int reverse(int num) {
    int res = 0;
    while (num != 0) {
        int t = num % 10;
        res = res * 10 + t;
        num /= 10;
    }
    return res;
}
```

{% note success flat %}
执行用时：52 ms, 在所有 Java 提交中击败了50.31%的用户
内存消耗：55.7 MB, 在所有 Java 提交中击败了22.09%的用户
{% endnote %}

---
