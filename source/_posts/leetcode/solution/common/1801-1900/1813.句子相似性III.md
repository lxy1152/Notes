---
title: 1813.句子相似性 III
katex: true
categories:
  - LeetCode
  - 题解
  - 1801-1900
description: 第 49 场双周赛，需要在字符串两侧同时查找
tags:
  - 周赛
  - 字符串
abbrlink: 720172fd
date: 2021-04-06 11:37:06
cover: https://rmt.dogedoge.com/fetch/~/source/unsplash/photo-1617626934148-83aa91920420?ixid=MXwxMjA3fDB8MHx0b3BpYy1mZWVkfDEwfGJvOGpRS1RhRTBZfHxlbnwwfHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=500&q=80
---

## 题目信息

### 题目描述

一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，`"Hello World"`，`"HELLO"`，`"hello world hello world"` 都是句子。每个单词都 只包含**大写和小写英文字母**。

如果两个句子 `sentence1` 和 `sentence2`，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是相似的。比方说，`sentence1 = "Hello my name is Jane"`，`sentence2 = "Hello Jane"`，我们可以往 `sentence2` 中的 `"Hello"` 和 `"Jane"` 之间插入 `"my name is"` 得到 `sentence1`。

给你两个句子 `sentence1` 和 `sentence2`，如果 `sentence1` 和 `sentence2` 是相似的，请返回 `true`，否则返回 `false`。

{% note info flat %}
- `1 <= sentence1.length, sentence2.length <= 100`
- `sentence1` 和 `sentence2` 都只包含大小写英文字母和空格
- `sentence1` 和 `sentence2` 中的单词都只由单个空格隔开
{% endnote %}

### 示例输出

{% tabs sample %}
<!-- tab 示例输出1 -->
输入： `sentence1 = "My name is Haley", sentence2 = "My Haley"`
输出： `true`
<!-- endtab -->

<!-- tab 示例输出2 -->
输入： `sentence1 = "of", sentence2 = "A lot of words"`
输出： `false`
<!-- endtab -->

<!-- tab 示例输出3 -->
输入： `sentence1 = "Eating right now", sentence2 = "Eating"`
输出： `true`
<!-- endtab -->

<!-- tab 示例输出4 -->
输入： `sentence1 = "Luky", sentence2 = "Lucccky"`
输出： `false`
<!-- endtab -->
{% endtabs %}

## 解题思路

从左右两边同时查找首个单词不一样的位置，如果相同的单词个数与两字符串中单词数量较小的那一个的单词个数相同就代表是相似的。

## 代码实现

```java
public boolean areSentencesSimilar(String sentence1, String sentence2) {
    String[] partsOfOne = sentence1.split(" ");
    String[] partsOfTwo = sentence2.split(" ");

    int length1 = partsOfOne.length;
    int length2 = partsOfTwo.length;

    int left = 0;
    int right = 0;

    // 从左边遍历, 找到首个单词不同的位置
    while (left < length1 && left < length2) {
        if (partsOfOne[left].equals(partsOfTwo[left])) {
            left++;
        } else {
            break;
        }
    }

    // 如果左侧直接就把数组遍历完了, 直接返回
    if (left == length1 && left == length2) {
        return true;
    }

    // 从右边遍历, 找到首个单词不同的位置
    while (right < length1 && right < length2) {
        if (partsOfOne[length1 - right - 1].equals(partsOfTwo[length2 - right - 1])) {
            right++;
        } else {
            break;
        }
    }

    // 判断长度与字符串长度是否一致
    return (right + left) == Math.min(length1, length2);
}
```

{% note success flat %}
执行用时：1 ms, 在所有 Java 提交中击败了95.97%的用户
内存消耗：36.9 MB, 在所有 Java 提交中击败了23.83%的用户
{% endnote %}

---
