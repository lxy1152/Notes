---
title: 1801.积压订单中的订单总数
date: 2021-03-21 22:28:45
katex: true
categories:
  - LeetCode
  - 题解
  - LeetCode
  - 1801-1900
abbrlink: '66488014'
description: 第233场周赛中的第二题，使用优先队列解决
cover: https://images.unsplash.com/photo-1508108712903-49b7ef9b1df8?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1650&q=80
tags:
  - 优先队列
  - 堆
  - 周赛
---

## 题目信息

### 题目描述

给你一个二维整数数组 `orders` ，其中每个 $orders[i] = [price_i, amount_i, orderType_i]$ 表示有 $amount_i$ 笔类型为 $orderType_i$，价格为 $price_i$ 的订单。

订单类型 $orderType_i$ 可以分为两种：

- `0`：表示这是一批采购订单（ `buy` ）
- `1`：表示这是一批销售订单（ `sell` ）

`orders[i]` 表示一批共计 $amount_i$ 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 `i`，由 `orders[i]` 表示的所有订单提交时间均早于 `orders[i+1]` 表示的所有订单。

存在由未执行订单组成的**积压订单**。积压订单最初是空的，提交订单时，会发生以下情况：

- 如果该订单是一笔采购订单 `buy` ，则可以查看积压订单中价格**最低**的销售订单 `sell`。如果该销售订单 `sell` 的价格**低于或等于**当前采购订单 `buy` 的价格，则匹配并执行这两笔订单，并将销售订单 `sell` 从积压订单中删除。否则，采购订单 `buy` 将会添加到积压订单中。
- 如果该订单是一笔销售订单 `sell` ，则可以查看积压订单中价格**最高**的采购订单 `buy` 。如果该采购订单 `buy` 的价格**高于或等于**当前销售订单 `sell` 的价格，则匹配并执行这两笔订单，并将采购订单 `buy` 从积压订单中删除。否则，销售订单 `sell` 将会添加到积压订单中。

在输入所有订单后，返回**积压订单中的订单总数** 。由于数字可能很大，所以需要返回对 $10^9 + 7$ 取余的结果。

{% note warning flat %}
注意：$1 <= orders.length <= 10^5$，$orders[i].length == 3$，$1 <= price_i, amount_i <= 10^9$，$orderType_i$ 为 0 或 1
{% endnote %}

### 示例输出

{% tabs sample %}
<!-- tab 示例输出1 -->
![ex1.png](https://i.loli.net/2021/04/02/ky1pv4xsiUaCzYo.png)
输入： `orders = [[10, 5, 0], [15, 2, 1], [25, 1, 1], [30, 4, 0]]`
输出： `6`
<!-- endtab -->

<!-- tab 示例输出2 -->
![ex2.png](https://i.loli.net/2021/04/02/Ch2eP8GMspHcoUT.png)
输入： `orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]`
输出： `999999984`
<!-- endtab -->
{% endtabs %}

## 解题思路

根据题目的叙述中的：价格**最低**的销售订单和价格**最高**的采购订单不难想到使用大小顶堆。对于买单需要使用大订单，这样队首总是价格最高的单；对于卖单需要使用小顶堆，这样队首总是价格最低的单。

对于买单和卖单地处理，其实逻辑都是一样的（如果是卖单，把买卖双方调换一下就可以了），下面以买单来举例：

新来了一批买单，首先要看看卖单中价格最低的是不是比我这一批订单的预计买入价钱还要低：
1. 确实有价钱便宜的卖单，那么这些订单就成功成交了，成交订单的数量等于买卖双方订单数量的最小值
   - 如果卖方已经卖完了，可是买方还没买完，那么买方需要继续看看还有没有其他可选择的订单了，如果有就继续成交
   - 如果买方已经买完了，可是卖方还没卖完，那么买方的工作就结束了，卖方需要继续挂单等待
2. 对于买方而言如果没有可供选择的卖单了（可能是因为真的没有卖单也可能是因为价钱不合适），那么这些买单就需要挂单等待
3. 随着新订单的加入，不断重复上面的步骤，直到没有新的订单了

如果所有订单都处理完了，剩余的买/卖单还没处理完，那么这些买单就叫做**积压订单**，最后需要返回这些订单的数量。

{% note info flat %}
如果对股票有一定了解，其实上面的过程跟盘口挂单是类似的，就是模拟买卖双方撮合成交的过程，在流程上可以类比一下。
{% endnote %}

## 代码实现

```java
public static int getNumberOfBacklogOrders(int[][] orders) {
    // 大顶堆
    Queue<int[]> buy = new PriorityQueue<>(Comparator.comparingInt(o -> -o[0]));
    // 小顶堆
    Queue<int[]> sell = new PriorityQueue<>(Comparator.comparingInt(o -> o[0]));

    // 遍历所有的订单
    for (int[] order : orders) {
        int price = order[0];
        int amount = order[1];
        int orderType = order[2];

        // 处理买单
        if (orderType == 0) {
            // 先看看能不能撮合一部分的订单
            while (amount > 0 && !sell.isEmpty()) {
                // 看看价格最便宜的卖单的价钱够不够便宜, 如果太贵了就不买了
                int[] sellOrder = sell.peek();
                if (price >= sellOrder[0]) {
                    // 如果价钱合适, 需要看看双方能成交多少
                    int selled = Math.min(amount, sellOrder[1]);
                    // 买卖双方将成交的部分减去
                    amount -= selled;
                    sellOrder[1] -= selled;
                    // 如果成交过后, 卖方没有可卖的了, 那么把这个卖单删掉
                    if (sellOrder[1] <= 0) {
                        sell.poll();
                    }
                } else {
                    break;
                }
            }

            // 如果没有订单可以撮合或者撮合过后还有剩余订单, 那么这些买单需要挂单等待
            if (amount > 0) {
                buy.offer(new int[]{price, amount, orderType});
            }
        }
        // 处理卖单, 逻辑同买单
        else {
            while (amount > 0 && !buy.isEmpty()) {
                int[] buyOrder = buy.peek();
                if (price <= buyOrder[0]) {
                    int bought = Math.min(amount, buyOrder[1]);
                    amount -= bought;
                    buyOrder[1] -= bought;
                    if (buyOrder[1] <= 0) {
                        buy.poll();
                    }
                } else {
                    break;
                }
            }
            if (amount > 0) {
                sell.offer(new int[]{price, amount, orderType});
            }
        }
    }

    // 订单都处理完成后, 看一下积压订单的数量
    int result = 0;
    for (int[] order : buy) {
        result = (result + order[1]) % 10_0000_0007;
    }
    for (int[] order : sell) {
        result = (result + order[1]) % 10_0000_0007;
    }

    return result;
}
```

{% note success flat %}
执行用时：54 ms, 在所有 Java 提交中击败了100.00%的用户
内存消耗：81.6 MB, 在所有 Java 提交中击败了100.00%的用户
{% endnote %}

---
